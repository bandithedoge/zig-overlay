#!/usr/bin/env nix-shell
#! nix-shell -p curl jq minisign -i sh
# shellcheck shell=sh
set -e

# The well known public key for Zig
PUBLIC_KEY="RWSGOq2NVecA2UPNdBUZykf1CCb147pkmdtYxgb3Ti+JO/wCYvhbAb/U"

rm -rf ./*index.json zig-index.json.minisig mirrors.json

# Grab the JSON and parse the version
curl -s 'https://ziglang.org/download/index.json' > zig-index.json
VERSION=$(jq -r '.master.version' < zig-index.json)
echo "Parsing master version: ${VERSION}"

# Verify the signature of the JSON before we parse it
curl -s "https://ziglang.org/builds/zig-${VERSION}-index.json.minisig" > zig-index.json.minisig
minisign -V -P ${PUBLIC_KEY} -x zig-index.json.minisig -m zig-index.json

# Merge Mach's index.json with the official one
curl -s 'https://machengine.org/zig/index.json' > mach-index.json
jq -s '.[0] * .[1]' mach-index.json zig-index.json > index.json

# Grab a list of mirrors for old nightly builds
curl -s 'https://raw.githubusercontent.com/mlugg/setup-zig/refs/heads/main/mirrors.json' > mirrors.json

# Build our new sources.json
jq '
["aarch64-linux", "x86_64-linux", "aarch64-macos", "x86_64-macos", "aarch64-windows", "x86_64-windows"] as $targets |

def todarwin(x): x | gsub("macos"; "darwin");

def filename(x): x | match("zig-.+-.+-.+.+\\.(?:tar\\.xz|zip)"; "g") | .string;

def toentry(vsn; x):
  [(vsn as $version |
    .value |
    to_entries[] |
    select(.key as $key | any($targets[]; . == $key)) | {
      (todarwin(.key)): {
        "file": filename(.value.tarball),
        "sha256": .value.shasum,
        "version": $version,
      }
    }
  )] | add | first(values, {});

reduce to_entries[] as $entry ({}; . * (
  $entry | {
    (.key): (
      if (.key != "master" and .key != "mach-latest") then
        toentry(.key; .value)
      else {
        "latest": toentry(.value.version; .value),
        (.value.date): toentry(.value.version; .value),
      } end
    )
  }
))
' < index.json > sources.new.json

# For debugging
# cat sources.new.json
# exit

# Copy the old file since jq can't modify in-place. This is also a backup.
cp sources.json sources.old.json

# Recursive merge
jq -s '.[0] * .[1]' sources.old.json sources.new.json > sources.json
